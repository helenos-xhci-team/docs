\chapter{Future Development}

This chapter outlines features, which were considered optional extensions of
the project but were not realized due to time, complexity or other constraints.
These features provide good starting points for the future development of the
USB stack.

\section{Power Management}

The xHCI Specification focuses a lot on power management. Devices have multiple
states corresponding to the amount of power used, and links between devices
do so as well. Of course, to fully utilize these features, there must have been
a system-wide mechanism to declare intentions about power management. We are not
there yet.

Despite that, there are a few power switches we could toggle just now. Given the
small number of drivers implemented, we could for example make the USB fallback
driver suspend the device.

We consider power management a topic that needs to be addressed on the
system level, and as such we did not pay much attention to it.

\section{Asynchronous I/O}

The aspect we care about though is performance. Although the primary goal of
this project was to allow users to use USB on machines equipped only with xHC,
the performance benefit of USB 3 is not negligible, and could be well worth it.

Every transfer type of USB focuses on different characteristics of the
transfer. Interrupt pipes strive for the lowest latency possible -- in this
field, the synchronous semantics works very well. The latency between receiving
interrupts and delivering them as fast as an IPC reply to a call.

Considering isochronous endpoints, it is simply not possible to satisfy them
with a synchronous API. For that reason, we decided to change the semantics to asynchronous
one. The downside of the current approach is that the HC driver is forced to
copy the data out from the shared buffer, because its ownership is temporary.
But since isochronous transfers in xHCI are just a proof-of-concept and
there are no drivers for real devices yet, we have decided not to optimize
prematurely.

The bulk transfer type can however be utilized both synchronously and
asynchronously, and both use cases have their advantages as well as disadvantages. While synchronous API is easier to
work with, asynchronous would offer much better performance though. However, as there is just
a single driver using bulk endpoints, we have decided not to complicate matters and stay
with synchronous-only API for bulk pipes.

\section{Isochronous Transfers in UHCI+OHCI+EHCI}

The isochronous module implemented in xHCI can be thought of as a generic scheduling
framework for isochronous transfers. The scheduler behaves like a leaky bucket,
scheduling the transfers to xHC at a constant rate while throttling the device
driver. This is the most complicated part of handling isochronous transfers,
and implementing an asynchronous API for drivers is a good opportunity to
generify it for other drivers as well.

Implementing the support for isochronous transfers for older HCs is a bit
harder task, though. Those drivers use proprietary data structures for isochronous
transfers, and require the software to schedule transfers so all time
constraints are satisfied. (The xHC does it in hardware, and software is just
responsible for issuing transfers fast enough.) Also, because of a heavily
simplified implementation of periodic scheduling in the former HC drivers,
substantial refactoring is inevitable. That however requires a deeper
understanding of inner workings of individual HCIs.
