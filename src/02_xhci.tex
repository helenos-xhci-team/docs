\chapter{xHCI Stack Implementation}

The structure of the xHCI driver is quite straightforward, as it tries to fit
into the scheme of how hardware and the rest of HelenOS works. We decided to
use the existing library \lib{libusbhost} to reduce code duplication with
other HC drivers. It came out that this library needs a lot of changes to
support us in this goal, but that's for chapter \ref{usb-refactoring}.

The USB host controller driver using \lib{libusbhost}, xHCI included, serves as
a connecting layer between the hardware and library, and exposes its bus
interface.

\begin{figure}[h]
	\centering
	\includegraphics[width=0.8\textwidth]{xhci-architecture}
	\caption{The modules of xHCI driver}
\end{figure}

The scheme is not at all strict, we're in a C world, there are dependencies
almost everywhere -- take it as an informal overview to get an idea.

The whole driver can be split into two parts. The left one takes care about the
hardware perception of what's going on, the right one is about managing the
software structures and memory.

We start with describing the modules in the hardware part, as their
functionality is clear. Their order follows the order in which they were
implemented.

\section{Hardware Structures}

The \file{uspace/drv/bus/usb/xhci/hw\_struct}{hw\_struct} directory contains C structures
that represent registers and control structures used by the xHC. The memory layout of the
structures is defined by the xHCI specification and thus the files in this directory should
be mostly treated as read-only.

\subsection{Registers}

The register structures (defined in \file{uspace/drv/bus/usb/xhci/hw\_struct/regs.h}{regs.h})
represent hardware registers presented by the xHC to system software
implemented as Memory-Mapped I/O space. They can be divided into four categories as follows:
~
\begin{description}
	\item[Capability registers]
		These specify read-only limits, restrictions and capabilities of the specific
		xHC implementation used.
	\item[Runtime and Operational registers]
		These specify the current xHC configuration and runtime modifiable state.
	\item[Extended capabilities]
		These specify optional features of the current xHC implementation.
	\item[Doorbell array]
		An array of up to 256 doorbell registers, which supports up to 255 USB devices
		or hubs. Each doorbell register provides the software with a mechanism for
		notifying the xHC if it has slot or endpoint related work to perform.
\end{description}

In our implementation, all of these can be accessed through the \struct{xhci_hc_t} structure and
can be modified through it using the register handling macros defined in
\file{uspace/drv/bus/usb/xhci/hw\_struct/regs.h}{regs.h}. Note that not all register bits can be
manipulated freely by the system, some impose restrictions:
~
\begin{description}
	\item[RO, Read-only]
		Register bits are read-only and cannot be altered by system software. An example
		is the \textit{CAPLENGTH} register (see \xhci{5.3.1}).
	\item[RW, Read-Write]
		Register bits are read-write and can be altered by system software. An example
		is the \textit{USBCMD} register (see \xhci{5.4.1}), in which some bits or bit ranges
		are RW (and some are read-only).
	\item[RW1C, Write-1-to-clear]
		Register bits indicate status when read, a set bit can be cleared by writing
		a '1', writing a '0' to such register bit has no effect. An example is
		the \textit{Event Interrupt} bit in the \textit{USBSTS} register (see \xhci{5.4.2}) which is set
		to '1' by the xHC when an interrupt occurs and can be cleared by the driver
		by writing '1' to it once the event is scheduled for handling.
	\item[RW1S, Write-1-to-set]
		Register bits indicate status when read, a clear bit can be set by writing
		a '1', writing a '0' to such register bit has no effect. Examples are the
		\textit{Command Stop} and \textit{Command Abort} bits of the \textit{CRCR} register
		(see \xhci{5.4.5}).
\end{description}

This is not an exhaustive list of access attributes, for the entire list, see \xhci{5.1.1}.

\subsubsection{Register access macros}

Registers are accessed very often in all hardware-related modules. We felt that
there is a need to centralize the information defined in specification,
especially the subdivision of registers to individual fields. There are several
common solutions to this problem.

Probably the most common one, which we also considered at first, is defining
two constants for every such field: mask and shift. When one needs to read
a field, they read the value of the register, use the mask to select bits, and
then shift the value according to the shift macro. To write a field, one reads
the value of the whole register, uses the bitwise negation of the mask to copy
surrounding bits, then shift the value to be written into its place. This
solution is simple to understand, yet hard to use correctly. There's a lot of
repetition, the more if you consider endianity (HelenOS is targeted also on Big
Endian platforms, while the USB world is Little Endian).

Another possibility is to define macros for reading and writing every single
field. That idea was discarded in its very beginning. We wanted a solution,
that requires only one definition per field, cannot be used in a wrong way and
is sensibly short to write. So we came up with the register access macros. The
best introduction is probably by an artificial example:

\begin{listing}[h]
\begin{code}
#define XHCI_SOME_FIELD            usbreg, 32, RANGE, 13, 7

unsigned field = XHCI_REG_RD(hc->op_regs, XHCI_SOME_FIELD);
XHCI_REG_WR(hc->op_regs, XHCI_SOME_FIELD, 42);
\end{code}
	\caption[An example of using register macros]{On the first line, we read
	bits 13 to 7 of the field \mintinline{c}{hc->op_regs->usbreg} to
	a variable, and then change the same bits in the register to a value 42.}
\end{listing}

All the definitions of macros like \macro{XHCI_SOME_FIELD} relevant for xHCI
are contained in the header file \header|hw_struct/regs.h|. The definition
contains all the information necessary to access the field. It says that the
register field is contained in a field \struct{usbreg} of an operational
register structure (the one \mintinline{c}{hc->op_regs} points to), the
structure field is a 32 bit wide dword, and that the register field is
contained in bits 13 to 7 of it.

The primary principle used to implement these preprocessor macros is the
specific order of macro expansion in C. In the example, the register definition
macro is used as an argument to the \macro{XHCI_REG_RD} macro. Both macros are
expanded in a breadth-first fashion, producing just another preprocessor macro
\macro{XHCI_REG_RD_INNER(hc->op_regs, usbreg, 32, RANGE, 13, 7)}. You can see
that one argument is expanded to several arguments for the inner macro. What
happens next is pretty simple. The \macro{RANGE} argument token is glued to
a prefix, producing a name for another macro, which selects between
implementations for whole fields, bit ranges and individual bit flags. The
\macro{XHCI_REG_RD_RANGE} then extracts the specified bits read from whole
field. The size argument is needed to properly handle endianity. All other
top-level macros (\macro{XHCI_REG_WR}, \macro{XHCI_REG_SET},
\macro{XHCI_REG_CLR}, \macro{XHCI_REG_MASK} and \macro{XHCI_REG_SHIFT}) operate
on the same principle.

We think we have achieved our goal. These macros are a bit hard to understand but
very easy to use, and require just one line of definition per field. Looking
back though, the work was probably not worth it -- the registers are not used
that much to justify existence of register definition of every single register
field. But it is already done and shall there be a need to access more registers,
it's easily accessible without thinking how to select the proper bits and
ensure the correct endianness. And even if there wasn't, it serves as a nice
showcase of what are preprocessor macros capable of.

\subsection{Contexts}

Contexts (defined in \file{uspace/drv/bus/usb/xhci/hw\_struct/context.h}{context.h})
are control structures that represent devices and their configuration as well
as the parameters of the communication between the xHC and system software. The
\struct{xhci_hc_t} structure contains the \textit{Device Context Base Address Array} (DCBAA), which
holds up to 255 pointers to device contexts at indices 1 through 255 and a pointer to
the scratchpad array (see \ref{sec:scratchpads}). Each device context contains a slot
context (used to describe the device as a whole, represented by \struct{xhci_slot_ctx_t}) and
31 context for each endpoint (represented by \struct{xhci_ep_ctx_t}). Most of these contexts
will be described in more detail in the following sections.

% TODO device & input ctx problem with 32-bit and 64-bit?

\section{Debug}

Since both the internal state of the xHC and its capabilities are often described by
a handful of bits located in a packed 32-bit register, we needed a way to monitor these
values in a human readable form. The \file{uspace/drv/bus/usb/xhci/debug.h}{debug.h} and
\file{uspace/drv/bus/usb/xhci/debug.c}{debug.c} files contain a set of register dumping
functions that use the register reading macros described in the previous section to print
the values of all the bit sets contained in a register to the driver's log. They also contain
auxiliary functions that are used to convert numeric codes to their meaning in a string form and
functions that dump the contents of a hardware structure (such as \struct{xhci_endpoint_ctx}).

These functions have proved to be of great use and should any future maintainer of the
HelenOS xHC stack find themselves in a bug ridden situation, putting these functions to
the areas of code they suspect of mischievous deeds might be a good starting point.

\input{02_trb_ring}

\section{Scratchpad}
\label{sec:scratchpads}

Scratchpads are buffers that an xHC implementation can request from the system software
for its internal needs. The size of these buffers is specified in the \textit{PAGESIZE} register
found in the operational register set defined in \struct{xhci_op_regs}.

The amount of buffers requested by the xHC is specified in the \textit{Max Scratchpad Bufs Hi} and
\textit{Max Scratchpad Bufs Lo} registers of the second set of structural parameters (\textit{HCSPARAMS2},
see \xhci{5.3.4}) defined in \struct{xhci_cap_regs}.

The allocation of these buffers takes place as part of the host controller initialization,
specifically in \fnc{hc_init_memory()}, which calls \fnc{xhci_scratchpad_alloc()}. The pointers
to these buffers are then passed to the xHC in the \textit{Scratchpad Buffer Array}, pointer to which
occupies the first index of the \textit{Device Context Base Address Array} (dcbaa field of
\struct{xhci_hc_t}).

Our implementation originally implemented these as a standalone structure \struct{xhci_scratchpad_t},
which served mainly for the purposes of resource management by keeping both the physical addresses
for the xHC and the virtual addresses for deallocation. This was, however, later refactored to use
\struct{dma_buffer_t}, which is part of \lib{libusbhost} and was created for the same purpose.

Once the xHCI driver finishes its execution, the scratchpad buffers are deallocated by a call to
\fnc{xhci_scratchpad_free()} as part of \fnc{hc_fini()}.


\input{02_commands}

\section{Host Controller Module}

\subsection{Events}
\label{sec:events}
% TODO: Explain events, event handling and the event ring.

% TODO: This will be harder, this one is a mix of what didn't fit anywhere else.
% Ideas:
% - context management
% - extcap parsing
%     - different speeds for different RH ports

\section{Root Hub}

The purpose of this module is very simple -- take care of the root hub. Before
we explain how our roothub works, let's have a look on why and how other HC
drivers handle it.

The main problem a hub driver faces is a synchronization one. When a new device
is detected, it needs to be enumerated. Enumeration process in the case of USB 2.0
devices requires the hub to reset the port the device is attached to, to move
it to the \state{Default} state, when it's listening on the default address 0.
When the port reset is triggered, the hub must wait until the port reset is
complete. During the whole process, the device can be disconnected, and the
port reset will never be completed. Furthermore, the completion of port reset
is indicated by the same means as port connection, resulting in a deadlock in
the na\"ive solution. The proper solution therefore involves spawning new
fibrils and nontrivial synchronization.

All four HC drivers (UHCI, OHCI, EHCI and VHC) are using a virtual roothub. In
principle that means that they create a virtual USB device, which is listening
at the default address in the beginning, and trigger an enumeration process.
Then there is a little branch in transfer scheduling, that takes transfers
directed to the same address as the virtual device's, and delivers them by
calling a function instead. The virtual device behaves exactly like a real USB
hub would -- it has its standard descriptors, reply to setup requests and so
on. So it enumerates like a USB hub would, and creates a DDF device, which is
taken by the \texttt{usbhub} driver. The driver then handles the virtual
roothub like any other hub, by sending USB control transfers. The virthub
module translates USB transfers to callbacks, which are implemented by
individual HC drivers to read and modify register space of the Host Controller.

This solution is very clean in design, regarding that root hub functionality is
exactly the same as any other hub's, but just controlled by MMIO mapped
registers instead of USB packets. It is even recommended by the USB 2.0			% TODO: Link to USB2 spec
specification to embody this solution. But that's pretty much the only advantage
this solution has. One has to write a lot of code to even implement the
callbacks, not mentioning the virthub module itself. And a lot of code always
comes with bugs. Also, while having no real performance impact, it requires
several context switches, IPC calls, bouncing memory buffers and a lot of
unnecessary allocations to clear one bit in the register space (USB hubs
operate by setting and clearing so-called Features, indicating e.g. that
a connection on port changed). But it needs to be stressed more that this
performance impact is mitigated by the fact that real hubs use real USB transactions
above that and that hub interaction is very sparse.

We searched for a solution that would keep the cleanness in terms of shared
functionality between usbhub driver and roothub and decided to move the port
state machine and related fibril synchronization into the USB library. That
cleanly separates the hardest part of handling hub port changes from the code
that is actually handling them and enumerating the devices. This state machine
is used by both the xHCI roothub and also by the rewritten usbhub. More
information about this new module can be found in section \ref{hub-port-refactoring}.

One more thing related to the xHCI roothub, which we crossed while debugging on
real hardware: the USB hub have a bit dedicated to indicate that a port is
enabled (PED), and the port can be disabled using it. Counterintuitively, the
port is disabled by writing a 1 to it. Even worse, this bit is in the same
field as the change bits with RW1C semantics are -- which means that the
standard approach of reading and writing back the value read fails hard. This
took us several hours to discover, because the port reset was completed
successfully, but right after that, the device was inaccessible, even when we
didn't do anything with it yet. To make matters more complicated, QEMU ignores
this bit completely, so the code worked fine in a virtual environment.

\section{Bus Module}

% TODO: After the device will be split, will there be anything interesting to write about?

\subsection{Device}

% TODO: Enumeration, device context

\subsection{Endpoint}

% TODO: Contexts, rings

\input{02_transfers}
