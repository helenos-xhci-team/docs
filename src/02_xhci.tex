\chapter{xHCI Stack Implementation}

The structure of the xHCI driver is quite straightforward, as it tries to fit
into the scheme of how hardware and the rest of HelenOS works. We decided to
use the existing library \lib{libusbhost} to reduce code duplication with
other HC drivers. It came out that this library need a lot of changes to
support us in this goal, but that's for chapter \ref{usb-refactoring}.

The USB host controller driver using \lib{libusbhost}, xHCI included, serves as
a connecting layer between the hardware and library, and exposes its bus
interface.

\begin{figure}[h]
	\centering
	\includegraphics[width=0.8\textwidth]{xhci-architecture}
	\caption{The modules of xHCI driver}
\end{figure}

The scheme is not at all strict, we're in a C world, there are dependencies
almost everywhere -- take it as an informal overview to get an idea.

The whole driver can be split into two parts. The left one takes care about the
hardware perception on what's going on, the right one is about managing the
software structures and memory.

We start with describing the modules in the hardware part, as their
functionality is clear. Their order follows the order in which they were
implemented.

\section{HW structs}

% TODO: Explain that this one is really simple, and just mirrors the structures
% hardware use.

\section{Debug}

% TODO: Describe that we used it during debugging to check what we're doing.

\section{TRB ring}

% TODO @aearsis: explain the TRB rings, what they do and how they're
% implemented (ْ±2 pages, bore the reader to death right now!)
\subsection{Purpose}
\subsection{Implementation}

\section{Scratchpad}

Scratchpads are buffers that an xHC implementation can request from the system software
for its internal needs. The size of these buffers is specified in the \textit{PAGESIZE} register
found in the operational register set defined in \struct{xhci_op_regs}.

The amount of buffers requested by the xHC is specified in the \textit{Max Scratchpad Bufs Hi} and
\textit{Max Scratchpad Bufs Lo} registers of the second set of structural parameters (\textit{HCSPARAMS2},
see section 5.3.4 of the xHCI specification) defined in \struct{xhci_cap_regs}.

The allocation of these buffers takes place as part of the host constroller initialization,
specifically in \fnc{hc_init_memory()}, which calls \fnc{xhci_scratchpad_alloc()}. The pointers
to these buffers are then passed to the xHC in the \textit{Scratchpad Buffer Array}, pointer to which
occupies the first index of the \textit{Device Context Base Address Array} (dcbaa field of
\struct{xhci_hc_t}).

Our implementation originally implemented these as a standalone structure \struct{xhci_scratchpad_t},
which served mainly for the purposes of resource management by keeping both the physical addresses
for the xHC and the virtual addresses for deallocation. This was, however, later refactored to use
\struct{dma_buffer_t}, which is part of \lib{libusbhost} was created for the same purpose.

Once the xHCI driver finishes its execution, the scratchpad buffers are deallocated by a call to
\fnc{xhci_scratchpad_free()} as part of \fnc{hc_fini()}.


\section{Events}

% TODO: Explain events, event handling and the event ring.

\input{02_commands}

\section{Host controller module}

% TODO: This will be harder, this one is a mix of what didn't fit anywhere else.
% Ideas:
% - event handling
% - context management
% - extcap parsing
% - register access macros

\section{Roothub}

% TODO: Explain why we do not have virthub. Who remembers the reasons?
% Otherwise it just uses libusb/port to do the interesting work.

\section{Transfers}

% TODO @salmelu (probably?): Write something about it.

\subsection{Isochronous transfers}

% TODO @salmelu: Copy that from the wiki :)

\section{Bus module}

% TODO: After the device will be split, will there be anything interesting to write about?

\subsection{Device}

% TODO: Enumeration, device context

\subsection{Endpoint}

% TODO: Contexts, rings

\subsection{Streams}

% TODO @salmelu: Noone else understands that now.
