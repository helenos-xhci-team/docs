\chapter{Benchmarks and Testing}
\label{appendix:testing}

To demonstrate and benchmark performance of the xHCI stack, a proprietary
subsystem has been implemented in HelenOS. The primary function of this
subsystem is to communicate with a custom QEMU USB device over arbitrary
endpoints and provide statistical information related to the communication.
This way, it can be used to verify the correctness of message transmission,
experiment with synchronization and to measure performance indicators.

In addition, since the subsystem is built on top of the USB device driver
framework and has no xHCI-specific requirements, it can be also used to compare
parameters of the xHCI stack with its predecessors.

The subsystem is composed of three parts:
%
\begin{description}
	\item[QEMU fork with proprietary diagnostic device (usb-tmon)]
		This implementation of QEMU contains a virtual USB device, which carries
		the diagnostic device class descriptor.
	\item[USB Diagnostic Device Driver (usbdiag)]
		The usbdiag driver matches with the QEMU diagnostic device and
		facilitates all communication with it. It also exposes a remote
		interface for all HelenOS applications.
	\item[User Frontend Program (tmon)]
		The tmon program is the primary user frontend in shell. It can use the
		interface exposed by usbdiag to perform various tests with diagnostic
		devices and return human-readable results.
\end{description}


\section{QEMU Device}
\label{sec:tmon}

The \texttt{usb-tmon} virtual device is a diagnostic class USB device
created to allow us to test all of the different transfer types on one device,
gather data about the throughput and speed of the communication and validate
the contents of the USB packets sent between HelenOS and a device.

In order to support communications of all types, the device contains an
endpoint for each direction of each transfer type -- i.e. interrupt, bulk and
isochronous. Since we want to both check the speed of the driver and the
correctness of the data sent, each endpoint is duplicated creating two
sets of endpoints -- first set, which does not validate the transferred data,
and a second set, which checks that each four bytes of the data equal to a
predefined macro \macro{CHECK}. Each of these endpoints has an associated
macro that contains its endpoint number which has the form of
\macro{EP_<type>_<direction>} for the first set and
\macro{CHECKED_EP_<type>_<direction>} for the second set, where \texttt{<type>}
can be \texttt{INT} for interrupt transfers, \texttt{BULK} for bulk transfers or
\texttt{ISOC} for isochronous transfers and \texttt{<direction>} can be either
\texttt{IN} or \texttt{OUT}.

\subsection{Monitoring}

Regardless of which of the aforementioned endpoint sets is used, the
\texttt{usb-tmon} device prints information about the transfers it handles
to QEMU's standard output:
%
\begin{description}
	\item[Interrupt]
		Time since last \texttt{IN} or \texttt{OUT} interrupt request in
		microseconds.
	\item[Bulk]
		Amount of bytes transferred in the last second for every second of an
		\texttt{IN} or \texttt{OUT} bulk transfer.
	\item[Isochronous]
		Notification about receiving the request.
\end{description}

\subsection{Implementation}

The implementation of this device is located in the file
\qemufile{hw/usb/dev-tmon.c}{dev-tmon.c} in the helenos-xhci-team/qemu fork of
the official QEMU repository. It contains several key structures and functions:

\begin{description}
	\item[USBTmonState]
		Structure that represents the current state of a \texttt{usb-tmon}
		device.
	\item[desc\_tmon, desc\_device\_tmon, desc\_iface\_tmon]
		These three structures form the descriptor of the device and contain
		information about the device's class, protocol, endpoints etc.
	\item[usb\_tmon\_class\_init]
		Called when QEMU starts, so it is used as a constructor function for the
		virtual device and all relevant data.
	\item[usb\_tmon\_realize]
		Called when an instance of the \texttt{usb-tmon} device gets created and
		is used to initialize a specific instance of \struct{USBTmonState}.
	\item[usb\_tmon\_handle\_attach]
		Called when an instance of the \texttt{usb-tmon} device gets attached to
		the guest OS.
	\item[usb\_tmon\_handle\_control]
		Called when the device receives a control request, in its current
		implementation simply forwards the request to QEMU via
		\fnc{usb_desc_handle_control}.
	\item[usb\_tmon\_handle\_data]
		Called when the device receives an interrupt, a bulk or an isochronous
		data request, determines the receiving endpoint, stores information
		about handled data and if needed, sends or validates a USB packet.
	\item[usb\_tmon\_\{int\textbar bulk\textbar isoc\}\_\{in\textbar out\}]
		Called on specific kinds of transfers and track sent/received data.
\end{description}

These are the structures and functions one needs to modify in order to modify
the behavior of the device. Additionally, the source code contains helper
functions (e.g. time measurement with \fnc{get_now_sec} and \fnc{get_now_usec})
and QEMU debugging/informational functions and structures (e.g.
\struct{desc_strings}, \struct{vmstate_usb_tmon}, \struct{usb_tmon_info} and
\fnc{usb_tmon_register_types}). These should seldom require modification.

For the purposes of modifying or debugging usb-tmon's source code, the header
\qemufile{include/hw/usb.h}{usb.h} contains most of the structure definitions
and function declarations that might be needed.

\subsection{Usage}

To attach an instance of the \texttt{usb-tmon} device to a running QEMU, one
can type \textit{"device\_add usb-tmon"} into QEMU's monitor (which can be
accessed via the Ctrl-Alt-2 key combination or by redirecting the
monitor to QEMU's standard IO by adding \textit{"-monitor stdio"} to QEMU's
startup command). To have QEMU start with \texttt{usb-tmon} attached, they may
add \texttt{"-device usb-tmon"} to their QEMU startup command.


\section{Driver}

The diagnostic device driver (known as \texttt{usbdiag}) is a proprietary device
driver. Although it matches with all devices of the \textit{Diagnostic} class,
its main purpose is to communicate with the \texttt{usb-tmon} virtual device
described in the previous section through a simple protocol.

To the rest of the system, the driver offers a simple interface, which allows to
schedule tests to various endpoints of the diagnostic device. The output of such
tests is a performance measurement (number of transfers performed and duration
of all transfers) and optionally, a verification signalling that the data has
not been malformed by the communication channel.


\subsection{Structure}

The \texttt{usbdiag} driver consists of the following source files:
%
\begin{description}
	\item[\file{uspace/drv/bus/usb/usbdiag/main.c}{main.c}]
		Main entry point, hooks for the USB device driver interface.
	\item[\file{uspace/drv/bus/usb/usbdiag/device.h}{device.h},
		  \file{uspace/drv/bus/usb/usbdiag/device.c}{device.c}]
		Diagnostic device descendant of the \struct{usb_device_t} structure,
		endpoint mapping.
	\item[\file{uspace/drv/bus/usb/usbdiag/tests.h}{tests.h},
		  \file{uspace/drv/bus/usb/usbdiag/tests.c}{tests.c}]
		IN and OUT diagnostic tests, data verification, hooks for RPC.
\end{description}

\subsection{Usage}

Although the driver interface is open to all system applications, it is expected
to be used only from the frontend application described in the next section. The
exposed API is in detail described in
\file{uspace/lib/drv/include/usbdiag\_iface.h}{usbdiag\_iface.h} and consists of
four functions:
%
\begin{description}
	\item[\fnc{usbdiag_connect}] Open an IPC session with a diagnostic device.
	\item[\fnc{usbdiag_disconnect}] Close IPC session with a diagnostic device.
	\item[\fnc{usbdiag_test_in}] Initiate a synchonous test on an IN endpoint.
	\item[\fnc{usbdiag_test_out}] Initiate a synchronous test on an OUT
		endpoint.
\end{description}

Quite obviously, the API follows a simple communication session paradigm. After
a communication session is initiated, the user application can initiate multiple
tests on the diagnostic device before closing the session and terminating the
communication channel.

Since in order to initiate a session, the caller must already have a specific
diagnostic device in mind, the \texttt{usbdiag} driver defines a
\macro{USBDIAG_CATEGORY}, which marks all DDF functions exposing the
corresponding interface. This category can also be used to query the list of
device functions using the \fnc{loc_category_get_svcs} function provided by the
system \textit{Location Service}.


\section{Frontend}

\subsection{Structure}

The \texttt{tmon} application consists of the following source files:
%
\begin{description}
	\item[\file{uspace/app/tmon/main.c}{main.c}]
		Main entry point, command selection and usage string.
	\item[\file{uspace/app/tmon/commands.h}{commands.h}]
		Executable commands.
	\item[\file{uspace/app/tmon/list.c}{list.c}]
		Implementation of the \textit{"list"} command.
	\item[\file{uspace/app/tmon/tf.h}{tf.h}, \file{uspace/app/tmon/tf.c}{tf.c}]
		Testing framework, common code for all "\fnc{test-*}" commands.
	\item[\file{uspace/app/tmon/resolve.h}{resolve.h},
		  \file{uspace/app/tmon/resolve.c}{resolve.c}]
		Resolving DDF device from string using devman's IPC interface.
	\item[\file{uspace/app/tmon/burst\_tests.c}{burst\_tests.c}]
		Implementation of burst tests.
\end{description}

\subsection{Usage}

\begin{bdsh}
tmon: benchmark USB diagnostic device

Usage: tmon command [device] [options]

      list - Print a list of connected diagnostic devices.
      test-intr-in - Read from interrupt endpoint as fast as possible.
      test-intr-out - Write to interrupt endpoint as fast as possible.
      test-bulk-in - Read from bulk endpoint as fast as possible.
      test-bulk-out - Write to bulk endpoint as fast as possible.
      test-isoch-in - Read from isochronous endpoint as fast as possible.
      test-isoch-out - Write to isochronous endpoint as fast as possible.

      -n --cycles
            Set the number of read/write cycles.
      -s --size
            Set the data size transferred in a single cycle.

If no device is specified, the first device is used provided that it is the
only one connected. Otherwise, the command fails.

\end{bdsh}

\section{Massive Surprise Removal Testing}

As a simple tool to test multiple scenarios regarding device removal, we wrote
a shell script. It helped us find a lot of synchronization issues in hub driver
and HC drivers. The setup is very simple -- just run HelenOS in QEMU with
a management socket located at \mintinline{bash}{$SOCKFILE}:

\begin{bdsh}
$ qemu-system-x86_64 -qmp unix:$SOCKFILE,server,nowait \
	-device nec-usb-xhci -boot d -cdrom image.iso
\end{bdsh}

Then, assuming a QEMU build in a directory \mintinline{bash}{$QEMU_ROOT}, run
the following snippet:

\begin{bdsh}
: ${repeats:=1} ${count:=1} ${driver:=usb-hub}
: ${in_delay:=5} ${out_delay:=$in_delay}

for rep in $(seq 1 $repeats); do
	for i in $(seq 1 $count);do
		echo "device_add driver=$driver id=burst-$i"
	done

	sleep $in_delay

	for i in $(seq 1 $count);do
		echo "device_del id=burst-$i"
	done

	sleep $out_delay
done | python2 "$QEMU_ROOT/scripts/qmp/qmp-shell" "$SOCKFILE" >/dev/null
\end{bdsh}

The first two lines set default values for various parameters. There are
several combinations which we consider interesting.

\subsection{Fast Attach-Detach Test}

In this test, we used a ridiculously big value of \texttt{repeats}, and very
short value of \texttt{in\_delay}, something like a tenth of a second. Running
the script then simulates e.g. a bad cable, which stays connected only for
a short while.

This test does not work correctly with xHCI, because of a bug in QEMU that cannot
be worked around retaining correctness on real HW. QEMU correctly aborts
transfers in a case of device removal, but any transfer scheduled later is just
ignored. That's fine, the xHCI implementation issues a Stop Endpoint command to
force HC release the ring and allow it to deallocate abort the transfer itself.
Except that QEMU for some reason doesn't allow issuing a Stop Endpoint command
for the default control endpoint. So, in case of bad timing, we can issue
a transfer on EP 0 (like reading the device descriptor as a part of
enumeration) after QEMU knows that the device is removed, but we don't know it
yet. After that, we issue a Stop Endpoint command, which fails. Because we
cannot know whether the endpoint is used or not after the command fails, we
cannot simply abort the transfer. And because the disconnection handler fibril
must make sure the enumeration fibril is not stopped, this results in an
infinite waiting for QEMU response.

Note that this scenario simulates a real-world scenario, which does not happen
in virtual environment. So we consider it is acceptable that this test fails
because of QEMU.

Other HC drivers handled this test fairly well, because they do not maintain
a soft state in the hardware, they just poll transfers for completion. Thus
they know when it's safe to abort the transfer manually.

\subsection{Balloon test}

We used a scenario with a large number of \texttt{repeats}, large \texttt{count},
and long enough delays (like 15 seconds). We simulate a lot of devices connecting,
waiting for matters to stabilize, then disconnecting the devices again.

The main aspect this test is testing is resource leakage. When the resource
usage grows still after the first few rounds, something must be wrong. This
way, we found a leaking reference in \lib{libdrv}, which resulted in devices
never being dropped. That means that we were the first ever to actually remove
a device from HelenOS.

Also, we discovered that limits of HelenOS are much bigger than those of QEMU.
First, QEMU allows at maximum 64 slots per xHC to be enabled. Even though there
are 127 valid USB addresses available, you cannot connect more than 64 devices
at once. Even worse, after this limit is reached, QEMU will not report an error
-- it will simply enable a slot that is already enabled, resulting in correctly
failed assertions in our code.

The second controller that is failing under QEMU is OHCI, which has a hard
limit of 32 hops through the periodic queue. Because every hub (and HID device
too) has an interrupt endpoint, it is added to the periodic queue. QEMU makes
OHCI fail with an unrecoverable error after it reaches this limit of hops.
Because of it, you can connect at most 30 devices to OHCI under QEMU.

\subsection{Burst test}

The last parameter combination we tried was a bursting one. Using
\texttt{repeats = 1}, \texttt{count = 60}, and \texttt{in\_delay = out\_delay
= 4}. This combination connects a subtree of 60 hubs, and allows an arbitrary
subtree of them to enumerate. The disconnection comes during the enumeration,
which is a tough test for the hub driver. The more considering that the
disconnection comes for all devices at once.

Running this test started the hub refactoring described in section
\ref{hub-port-refactoring}, because neither the hub driver, nor our roothub at
that time was prepared for such situations, and failed hard multiple times.
Also, using this test we discovered the fundamental problem of flat hierarchy
presented to DDF, which is explained in the section \ref{hub-port-refactoring}
as well.

\section{Automated Removal Testing}

% TODO

\section{Try it yourself}

% FIXME: should this be even a separate appendix?

This section provides a brief crashcourse on how to get our work running.

After cloning our repository, HelenOS should be compiled as usual according to
the official guide. Namely, the following two commands should suffice given
that necessary build dependencies are installed:

\begin{bdsh}
$ ./tools/toolchain.sh amd64
$ make PROFILE=amd64
\end{bdsh}

\subsection{Running in QEMU}

A reasonably recent (version 2.10 or newer) QEMU is required.

The script \texttt{ew.py}, which is the official way to launch QEMU with
correct parameters, has been modified to include both an xHCI controller and a
USB tablet device (as introduced in \ref{sec:usb-tablet-driver}) by default.
Therefore, one should just run:

\begin{bdsh}
$ ./tools/ew.py
\end{bdsh}

After the system starts, the tablet device should function correctly. The log
of the HelenOS xHCI driver can be viewed with

\begin{bdsh}
$ edit /log/xhci
\end{bdsh}

Other related logfiles are \texttt{/log/usbhub}, \texttt{/log/usbhid} and
\texttt{/log/usbmid}.

\subsection{Testing with tmon}

\texttt{usb-tmon} (described in \ref{sec:tmon}) is a custom USB device emulated
by QEMU. \texttt{tmon} allows us to read and write data to and from endpoints
types and provides some diagnostics.

To use \texttt{usb-tmon}, first compile our version of QEMU that contains the
\texttt{usb-tmon} driver:

\begin{bdsh}
$ cd qemu
$ mkdir build; cd build
$ ../configure --target-list=x86_64-softmmu
$ make
\end{bdsh}

Then start HelenOS in your freshly-compiled QEMU:

\begin{bdsh}
$ ./tools/ew.py -qemu_path ../qemu/build/x86_64-softmmu/
\end{bdsh}

Then switch to the QEMU monitor (Ctrl+Alt+2) and enter \texttt{device\_add
usb-tmon}. Then switch back to HelenOS (Ctrl+Alt+1) and enter \texttt{tmon
list} to the console. A new device should appear. Now you can start the test,
for example with:

\begin{bdsh}
$ tmon test-bulk-in
\end{bdsh}

\subsection{Running on real hardware}

Our work has been tested on a desktop with Teratrend $\mu$DP720202 Rev. 1.0
PCIe card and on a ThinkPad x240 laptop with Intel 8 series xHC (PCI ID
8086:9C31).  Regarding peripherials, several noname and branded USB2 and USB3
hubs, mice, keyboards, multi-interface keyboards (with multimedia keys) and
flash drives have been tested.

It is possible to boot \texttt{image.iso} on the target computer, however
booting over the network proved to be much more convenient during development.
For netboot, we used GRUB instead of the more widespread pxelinux, as HelenOS
uses \texttt{multiboot} protocol and pxelinux does not support it.

The following commands can be used to generate a PXE GRUB image:

\begin{bdsh}
$ grub-mkimage --format=i386-pc --output=core.img --prefix="(pxe)" pxe tftp
$ cat /usr/lib/grub/i386-pc/pxeboot.img core.img > grub2pxe
\end{bdsh}

Then \texttt{/usr/lib/grub/i386-pc}, all files from
\texttt{helenos/boot/distroot/boot/} and the following \texttt{grub.cfg} are
placed to the TFTP server root and \texttt{grub2pxe} is booted.

\begin{bdsh}
set timeout=1
insmod multiboot
menuentry "helenos" {
  set root=(pxe)
  multiboot /kernel.bin
  module    /ns /boot/ns
  module    /loader /boot/loader
  module    /init /boot/init
  module    /locsrv /boot/locsrv
  module    /rd /boot/rd
  module    /vfs /boot/vfs
  module    /logger /boot/logger
  module    /ext4fs /boot/ext4fs
  module    /initrd.img /boot/initrd.img
}
\end{bdsh}
