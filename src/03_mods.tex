\chapter{USB Subsystem Modifications}
\label{usb-refactoring}

% TODO

\input{03_disconnect}
\input{03_polling}

\section{A Library Module for USB Hubs}
\label{hub-port-refactoring}

We introduced a new module to support writing hub drivers:
\file{uspace/lib/usb/include/usb/port.h}{usb/port.h}. It solves the problem of
hub drivers, that events are announced through a single channel, even though
they need to wait for each other. The implementation of this module was
motivated not only by the need of refactoring, nor because we wanted to share
the functionality with the xHCI driver, but because the previous implementation
of \lib{usbhub} driver synchronized the fibrils wrong. There might have been
situations in which two fibrils were spawned and enumerated the same device.

To solve the issue a state information is managed for every port, represented
by the structure \struct{usb_port_t}. It contains the current port state, one
of the following:

\begin{description}
\begingroup \leftskip=1cm \rightskip=\leftskip
\setcounter{enumi}{-1}
	\item[\state{Disabled}]
		There has been no activity on the port yet, or it is already over.
		Initial state.

	\item[\state{Connecting}]
		A connected event came, the enumerating fibril was started. It hasn't
		finished yet, so the device is not enumerated yet. Also, the device is
		still connected, no error event came while the connecting is in
		progress.

	\item[\state{Enumerated}]
		The device was successfully enumerated, so it has to be removed after
		it will be disconnected.

	\item[\state{Disconnecting}]
		A disconnected event came after the device was enumerated, so
		a removing fibril was started.

	\item[\state{Error}]
		An event about the device disconnection state came while the
		enumeration was in progress, so the enumeration fibril has to be
		stopped. This is achieved by returning \macro{EINTR} from the waiting
		methods.

\endgroup
\end{description}

The basic synchronization invariant is that the state never changes unless the
guard is locked. It is expected that the guard is not held for a long time, so
the fibril generating events shall not be blocked indefinitely. The only
exception being the final phase of enumeration (announcing the device to the
bus), which once started, cannot be easily interrupted -- but this operation on
the bus is also expected to run for a limited time only.

The scheme of states and allowed transitions can be seen on figure
\ref{fig:port-states}.

\begin{figure}[h]
	\centering
	\includegraphics[width=0.6\textwidth]{port-states}
	\caption{A graph of port states and their transitions.}
	\label{fig:port-states}
\end{figure}

The transitions are triggered by delivering events to the module. This is done
by calling following functions:

\begin{itemize}
	\item \fnc{usb_port_connected}
	\item \fnc{usb_port_disabled}
	\item \fnc{usb_port_enabled}
\end{itemize}

The \fnc{connected} and \fnc{disabled} functions take a callback as an
argument. If the respective state transition is triggered, this callback is run
in a separate fibril. These functions can block to obtain the port guard, and
the \fnc{disabled} event can furthermore block while waiting for the
enumeration fibril to terminate. But before it does, it makes sure the worker
will be notified as soon as possible.

To make it work, the callbacks must not block while holding the guard. They
can, however, wait for the enabled event, signalling the completion of port
reset, using a function \fnc{usb_port_wait_for_enabled}. The caller is required
to check the return value of it -- it can either finish with \macro{EOK},
timeout with \macro{ETIMEOUT} or be interrupted with \macro{EINTR}. The enabled
event is sent by calling the function \fnc{usb_port_enabled}.

When this fibril management is separated, an implementation of USB hub driver or
root hub driver is very simple. The hub driver just initializes the
\struct{usb_port_t} structure for every port it manages, then waits for events
from the hardware (either by poling the \textit{Status Change Endpoint}, or by
waiting for an interrupt), and forwards the events to this module, providing an
implementation of the enumeration and removal process.

One last thing to note is what to do when the structure is finalized, but
a device is still connected. It might happen that there is a subtree of devices
and hubs being removed because the subtree root $R$ has been unexpectedly
removed. In that case, a port disconnect is delivered to the parenting hub,
which triggers the device removal process. The hub $R$ then receives the DDF
signal \fnc{device_offline}, and starts removal if his own children. But
there's a catch: USB hierarchy is presented as a flat one to the DDF framework.
That means that the devman has no clue about hubs (it sees them as ordinary USB
devices), and considers that all of them are connected to the HC directly.
Device removal is prepared for the situation that device will remove also its
\textit{children} devices, but serializes removal of \textit{sibling} devices.
Therefore, recursive removal of hubs creates a deadlock in devman.

Fortunately, the HC driver must be prepared for badly written drivers, so it
cleans up after the device function is unbound. This cleanup includes also
removal of its former children devices -- so the workaround for this problem is
simply leaving those devices connected, as the HC will remove them itself. This
state transition is denoted by dotted line in the graph, and is triggered by
finalizing the port structure while a device is enumerated.

\section{USB Tablet Driver}

This modification is very standalone and seemingly simple, yet very useful and
appreciated. We extended the HID driver to support absolutely positioned
devices. That means, one can now connect a USB tablet and it will work in
HelenOS. If you are still wondering what this could be useful for (people using
USB tablets are usually graphic designers or photographers, not microkernel
developers), try running QEMU with an emulated one:

\begin{bdsh}
$ qemu-system-x86_64 -enable-kvm -usb -device usb-tablet -boot d -cdrom image.iso
\end{bdsh}

When using mouse with relative positioning (PS/2, USB mouse), one has to first
click inside the window of QEMU to let it grab input. To release it again,
a special key combination (for current QEMU Ctrl+Alt+G) must be pressed. When
using an emulated USB tablet instead, the mouse is not ``locked'' inside the
window, but it can freely move in and out and still be registered by the guest
OS.

\section{DMA buffers}

A simple but repeated scenario gave rise to another new submodule of
\lib{libusbhost}. It is a very thin abstraction, yet has been proven useful and we
think it could be adopted to \lib{libdrv}, for example.

A common task for drivers is allocating memory for buffers, that are accessible
for DMA. Often there are some restrictions given by the hardware driven -- the
buffer must be placed in the lower 32bit addressable space, it has to be
aligned, physically contiguous, or possibly not crossing a page boundary.

Even if the buffer is intended for the hardware use only (like xHCI
scratchpads), the driver must keep the pointer to where the buffer is mapped
inside its virtual address space in order to release the memory once it is not
needed anymore. Hardware devices do not share the virtual address space with
the task though, so the driver must always obtain also the physical address of
the buffer. To satisfy all of these requirements, the HelenOS kernel offers
a specialized API. The driver just needs to call a function
\fnc{dma_map_anonymous}, and is given both the virtual and physical address. It
is able to specify its requirements using flags. This API is powerful, but
complex and inconvenient to use.

The authors of the former USB stack addressed the complexity by creating
utility functions in \header|<usb/host/utils/malloc32.h>|. These functions offer
a familiar interface of \fnc{malloc}/\fnc{free}. The \fnc{malloc32} function
intentionally discards the physical address provided by
\fnc{dma_map_anonymous}, in order to be simple to use. To retrieve the physical
address later, one can use another utility function, \fnc{addr_to_phys}. This
one is a simple wrapper for a syscall.

Even previous authors of the USB subsystem were aware of it being a syscall,
and tried to cache the physical address where it would be used unneccessarily
multiple times. The usage scheme of these functions then grew wild: the memory
was allocated by \fnc{malloc32}, just to be translated by \fnc{addr_to_phys} on
the next line. These two pointers were then stored inside the same structure.

Being aware of this use-case, we created a different submodule for allocation
of DMA buffers. Instead of a plain pointer, the caller uses a structure called
\struct{dma_buffer_t}. This structure can store both the virtual and physical
address of the buffer, accessible through fields \struct{virt} and
\struct{phys}. The buffer allocation is made simply by using a function called
\fnc{dma_buffer_alloc}, which fills the specified buffer with pointers to
a properly sized allocated space. When the buffer is no longer needed, it is
freed by calling \fnc{dma_buffer_free}.

When the buffer is contiguous in memory, it's easy to calculate the physical
address ourselves, without a help of the kernel. To obtain a physical address
for a concrete position in the buffer, one just needs to call
\fnc{dma_buffer_phys}, which translates a virtual address pointing inside
a buffer to a corresponding physical address.

So far, DMA buffers always assume the strictest requirements for the allocated
memory. That is, the returned memory is page-aligned, physically contiguous,
always in the 32bit addressable space. Should there be a need to loosen one the
constraints (e.g. to reduce the memory footprint), the allocation routine can
be supplied a policy, defining the requirements. There is also a particular
future optimization, for which the mechanism is prepared. Especially the former
HC drivers often allocate a whole buffer, which must be at least
\macro{PAGE_SIZE} big, just to hold a few-bytes sized descriptor structure.
Shall the wasted memory be a problem, one can easily extend this module to use
an allocator in userspace to back DMA buffers.

One more reason to drop the previous \fnc{malloc32} helpers completely is that
developers that are beginners to HelenOS might see \fnc{malloc32} as a weird
name for an ordinary \fnc{malloc}, and start using it to allocate ordinary
memory, which is very wasteful and expensive.
